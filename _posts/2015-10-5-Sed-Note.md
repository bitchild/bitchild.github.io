---
title: Learning Note of Sed
---

> You must be heard the word, *on-the-fly*, when read some `sed` guide book. It's really a very powerful editor tool (we all know). So in this post, I wanna write down something of my journey in learning it. 

## The Key of Sed Editor ##

Please remember that the `sed` editor is a myriad of commands and formats. And here I described some of the basic commands and features, that you can make life easier. Oh! Another thing you should keep in mind is that `sed` won't modify the original file, but output to the **STDOUT**.

### Substitution Command ###

First, let's see how to replace matching patterns in the test string.

	$ cat a
	this line is line 0
	this line is line 1
	this line is line 2
	this line is line 3
	$
	$
	$ sed 's/line/row/' a
	this row is line 0
	this row is line 1
	this row is line 2
	this row is line 3
	
What result you got? By default, `sed` only replaces the first occurrence in each line. To make it work on different occurrences of the test, you must use a *substitution flag*. The syntax like below:

	s/pattern/replacement/flags
	
There are four options of subtitution flags available (cite from a book :>):

- A number, indicating the pattern occurrence for which new text should be substituted.
- g - Indicates that new text should be substituted for all occurrences of existing text.
- p - Indicated that the contents of the original line should be printed.
- w *file* - Write the results of the substitution to a file.

Ok! See some example and you will see it.

	$ sed 's/line/row/2' a
	this line is row 0
	this line is row 1
	this line is row 2
	this line is row 3

The above we specify a 2 as the substitution flag. Next is for flag *g*:

	$ sed 's/line/row/g' a
	this row is row 0
	this row is row 1
	this row is row 2
	this row is row 3

Ha, the left two flags I won't give example, but you can test them if you like.

Mention: Substituting pathnames (include forward slash) in a file can get awkward. When you deal with forward slash, you'd have to use backslash to escape it. Like this:

	$ sed 's/\/bin\/sh/\/bin\/csh/' /etc/passwd
	
### Using Address ###

By default, `sed` works on all lines of the text data. If you only want to apply to a specify line, or a range of lines, you must ust *line address*, like `[address]command`.

There are two form of line addressing in the `sed` editot:

- A numeric range of lines
- A text pattern that filters out a line

Examples will tell anything.
	
	$ sed -n '2s/line/row/gp' a
	this row is row 1
	$
	$ sed -n '2,$s/line/row/gp' a
	this row is row 1
	this row is row 2
	this row is row 3
	
Here I use `-n` option with flag p to suppresses output any line that has been modified. And the line number starts from 1, I worry you stay in C/C++. The '$' indicates the end line of file, similar to that in **vim** editor.


	
