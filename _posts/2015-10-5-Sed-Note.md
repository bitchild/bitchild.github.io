---
title: Learning Note of Sed
---

> You must be heard the word, *on-the-fly*, when read some `sed` guide book. It's really a very powerful editor tool (we all know). So in this post, I wanna write down something of my journey in learning it. 

## The Key of Sed Editor ##

Please remember that the `sed` editor is a myriad of commands and formats. And here I described some of the basic commands and features, that you can make life easier. Oh! Another thing you should keep in mind is that `sed` won't modify the original file, but output to the **STDOUT**.

### Substitution Command ###

First, let's see how to replace matching patterns in the test string.

	$ cat a
	this line is line 0
	this line is line 1
	this line is line 2
	this line is line 3
	$
	$
	$ sed 's/line/row/' a
	this row is line 0
	this row is line 1
	this row is line 2
	this row is line 3
	
What result you got? By default, `sed` only replaces the first occurrence in each line. To make it work on different occurrences of the test, you must use a *substitution flag*. The syntax like below:

	s/pattern/replacement/flags
	
There are four options of subtitution flags available (cite from a book :>):

- A number, indicating the pattern occurrence for which new text should be substituted.
- g - Indicates that new text should be substituted for all occurrences of existing text.
- p - Indicated that the contents of the original line should be printed.
- w *file* - Write the results of the substitution to a file.

Ok! See some example and you will see it.

	$ sed 's/line/row/2' a
	this line is row 0
	this line is row 1
	this line is row 2
	this line is row 3

The above we specify a 2 as the substitution flag. Next is for flag *g*:

	$ sed 's/line/row/g' a
	this row is row 0
	this row is row 1
	this row is row 2
	this row is row 3

Ha, the left two flags I won't give example, but you can test them if you like.

Mention: Substituting pathnames (include forward slash) in a file can get awkward. When you deal with forward slash, you'd have to use backslash to escape it. Like this:

	$ sed 's/\/bin\/sh/\/bin\/csh/' /etc/passwd
	
### Using Address ###

By default, `sed` works on all lines of the text data. If you only want to apply to a specify line, or a range of lines, you must ust *line address*, like `[address]command`.

There are two form of line addressing in the `sed` editor:

- A numeric range of lines
- A text pattern that filters out a line

Examples will tell anything.
	
	$ sed -n '2s/line/row/gp' a
	this row is row 1
	$
	$ sed -n '2,$s/line/row/gp' a
	this row is row 1
	this row is row 2
	this row is row 3
	
Here I use `-n` option with flag p to suppresses output any line that has been modified. And the line number starts from 1, I worry you stay in C/C++. The '$' indicates the end line of file, similar to that in **vim** editor.

	$ sed -n '/1/s/line/row/p' a
	this row is line 1
	
The above is for specifying a text pattern that it uses to filter lines for the command.
	
Also, if you need use more than one command on an individual line, you can do like this:
	
	$ sed '[address]{
		command 1 
		command 2
		...
		command n}' file

If you're interested, try it. Here I won't give any examples.

### Deleting Lines ###

The `delete` command is obviously most useful when used in conjunction with a specified address. But be careful, if you forget to include an addressing scheme, all of the lines will be deleted from the stream(don't worry, no original file)
	
	$ sed 'd' a     	--- nothing will output
	$ sed '1,3d' a
	this line is line 	--- only line 4 left
	$
	$ sed '/3/d; /2/d' 	--- the pattern-matching feature also applies the d command
	this line is line 0
	this line is line 1
	$
	
please think of this syntax: `sed '/2/,/5/d' a`. What will happen?

### Inserting and Appending Text ###

- The `insert` command (i) adds a new line before the specified line.
- The `append` command (a) adds a new line after the specified line.

The format for doing this is:

	sed '[address]command\new line' file	---be careful it is the backslash '\'
	
Here we see two simple examples.
	
	$ sed '1i\this line is new line' a	---if you don't specify a address number, another case.
	this line is new line
	this line is line 0
	...(ignore)
	$
	$ sed '1a\this line is new line' a
	this line is line 0
	this line is new line
	...(ignore)
	$

You may try to specify a range of address, and see what's the result!

### Changing Lines ###
